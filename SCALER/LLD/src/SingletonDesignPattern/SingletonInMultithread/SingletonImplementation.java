package SingletonDesignPattern.SingletonInMultithread;


public class SingletonImplementation {
    public static void main(String[] args){
        /* As we are looking forward to test our singleton class in a multithreaded environment,
        let's say there isn't any object initialized yet and two threads T1 and T2 are calling
        the getInstance() method at the same time then both will enter the check part at the
        same time and both will find that object is not yet initialized so both will create new
        objects and will use accordingly, but our class was singleton, this means our singleton
        approach is incomplete in terms of multithreaded environment.

        In multithreading, we have a concept of critical section, a part of program which is
        expected to create inconsistent results in case of multithreading, is called as critical
        section and here only one thread is allowed to process at a time, so here critical
        section is this

        if(instance == null){
            lock();
            instance = new SingletonClass();
            release();
        }

        if the object already exists, then there will be no collision amongst threads so the critical
        section is the check condition.

        We acquired lock on the critical section now it seems to be sorted, right ? No it isn't
        observe carefully, let's say three threads are accessing this at the same time so all three
        will be waiting at the same stage so all will acquire lock sequentially and all of them will
        again create new objects of their own.

        What we can do to restrict threads from accessing getInstance method simultaneously ? firstly,
        what is that exact point where it is failing ? it is failing at the if condition where we
        are checking if the object is initialized or not as all the threads are getting the same status
        as null, but they are entering the critical section one at a time that means we have to take
        control after they enter, so simply we can add another if condition to check if again instance
        is null then there won't be any more objects, understand it with an example

        if(instance == null){
            lock();
            if(instance == null){
                instance = new SingletonClass();
            }
            release();
        }

        so here even if the threads enter the first if condition, then the acquired lock will first
        create an object will leave with the generated instance but when next thread that is waiting
        at lock will again check that if the instance is generated or not and that time it will
        get the instance generated by previous thread, and it will get the same instance as previous
        and all the rest of the threads will also follow the same and when object is created and
        threads approach this section, they will directly get the object as method will directly
        return the generated object.

        In place of lock(), we can also use synchronized keyword which will also act as lock.
        * */

    }
}
